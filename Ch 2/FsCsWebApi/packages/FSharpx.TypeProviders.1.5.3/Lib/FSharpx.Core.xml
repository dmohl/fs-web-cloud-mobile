<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Core</name></assembly>
<members>
<member name="T:FSharp.Control.Agent`1">
<summary>
 Type alias for F# mailbox processor type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncSeqInner`1">
<summary>
 The interanl type that represents a value returned as a result of
 evaluating a step of an asynchronous sequence
</summary>
</member>
<member name="T:FSharp.Control.AsyncSeq`1">
<summary>
 An asynchronous sequence represents a delayed computation that can be
 started to produce either Cons value consisting of the next element of the 
 sequence (head) together with the next asynchronous sequence (tail) or a 
 special value representing the end of the sequence (Nil)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
<summary>
 Occurs when the execution of the agent results in an exception.
</summary>
</member>
<member name="P:FSharp.Control.AutoCancelAgent`1.Error">
<summary>
 Occurs when the execution of the agent results in an exception.
</summary>
</member>
<member name="P:FSharp.Control.AutoCancelAgent`1.CurrentQueueLength">
<summary>
 Returns the number of unprocessed messages in the message queue of the agent.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
<summary>
 Occurs when the execution of the agent results in an exception.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Scans for a message by looking through messages in arrival order until &lt;c&gt;scanner&lt;/c&gt; 
 returns a Some value. Other messages remain in the queue.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Waits for a message. This will consume the first message in arrival order.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Like PostAndReply, but returns None if no reply within the timeout period.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Start(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Start a new disposable agent using the specified body function
 (the method creates a new cancellation token for the agent)
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Scans for a message by looking through messages in arrival order until &lt;c&gt;scanner&lt;/c&gt; 
 returns a Some value. Other messages remain in the queue.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Waits for a message. This will consume the first message in arrival order.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Like PostAndAsyncReply, but returns None if no reply within the timeout period.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Posts a message to an agent and await a reply on the channel, synchronously.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Posts a message to an agent and await a reply on the channel, asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AutoCancelAgent`1.Post(`0)">
<summary>
 Posts a message to the message queue of the MailboxProcessor, asynchronously.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AutoCancelAgent`1">
<summary>
 Wrapper for the standard F# agent (MailboxProcessor) that
 supports stopping of the agent&apos;s body using the IDisposable 
 interface (the type automatically creates a cancellation token)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.remove_BatchProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. The
 group is not empty, but may not be of the specified maximal size
 (when the timeout elapses before enough messages is collected)
</summary>
</member>
<member name="P:FSharp.Control.BatchProcessingAgent`1.BatchProduced">
<summary>
 The event is triggered when a group of messages is collected. The
 group is not empty, but may not be of the specified maximal size
 (when the timeout elapses before enough messages is collected)
</summary>
</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.add_BatchProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. The
 group is not empty, but may not be of the specified maximal size
 (when the timeout elapses before enough messages is collected)
</summary>
</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.Enqueue(`0)">
<summary>
 Sends new message to the agent
</summary>
</member>
<member name="M:FSharp.Control.BatchProcessingAgent`1.System-IDisposable-Dispose">
<summary>
 Dispose
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.BatchProcessingAgent`1">
<summary>
 Agent that can be used to implement batch processing. It creates groups
 of messages (added using the Enqueue method) and emits them using the 
 BatchProduced event. A group is produced when it reaches the maximal 
 size or after the timeout elapses.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Control.BlockingQueueAgent`1.Count">
<summary>
 Gets the number of elements currently waiting in the queue.
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.Get(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Synchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
 This method blocks until value is available!
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.AsyncGet(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.AsyncAdd(`0,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.BlockingQueueAgent`1.Add(`0)">
<summary>
 Asynchronously adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed. This overload does not
 signal the caller that the item has been added.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.BlockingQueueAgent`1">
<summary>
 Agent that implements an asynchronous queue with blocking put
 and blocking get operation (this implements the producer-consumer 
 concurrent programming pattern). The constructor takes the maximal
 size of the buffer.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.Control.CircularQueueAgent`1.Count">
<summary>
 Gets the number of elements currently waiting in the queue.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Enqueue(`0[])">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Enqueue(System.ArraySegment{`0})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Enqueue(`0[],System.Int32,System.Int32)">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.Dequeue(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Synchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
 This method blocks until value is available!
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncEnqueue(`0[],Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncEnqueue(System.ArraySegment{`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncEnqueue(`0[],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Adds item to the queue. The operation ends when
 there is a place for the item. If the queue is full, the operation
 will block until some items are removed.
</summary>
</member>
<member name="M:FSharp.Control.CircularQueueAgent`1.AsyncDequeue(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously gets item from the queue. If there are no items
 in the queue, the operation will block until items are added.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.CircularQueueAgent`1">
<summary>
 Agent that implements an asynchronous circular buffer with blocking
 enqueue and blocking dequeue operation (this implements the producer-consumer 
 concurrent programming pattern). The constructor takes the maximal
 size of the buffer.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.ConcurrentSetAgent`1.AsyncAdd(System.Object)">
<summary>
 Adds the specified element to the set and returns 
 &apos;false&apos; when it was already present in the set
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.ConcurrentSetAgent`1">
<summary>
 Agent that implements a simple concurrent set. The agent exposes a 
 member that adds value to the set and returns whether the value
 was already present.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.ObservableUpdate`1">
<summary>
 Union type that represents different messages that can be sent to the
 IObserver interface. The IObserver type is equivalent to a type that has
 just OnNext method that gets &apos;ObservableUpdate&apos; as an argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.SlidingWindowAgent`1.remove_WindowProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. 
 The size of the group is exactly &apos;count&apos; and the values are
 returned in a fresh array.
</summary>
</member>
<member name="P:FSharp.Control.SlidingWindowAgent`1.WindowProduced">
<summary>
 The event is triggered when a group of messages is collected. 
 The size of the group is exactly &apos;count&apos; and the values are
 returned in a fresh array.
</summary>
</member>
<member name="M:FSharp.Control.SlidingWindowAgent`1.add_WindowProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. 
 The size of the group is exactly &apos;count&apos; and the values are
 returned in a fresh array.
</summary>
</member>
<member name="M:FSharp.Control.SlidingWindowAgent`1.Enqueue(`0)">
<summary>
 Sends new message to the agent
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Control.SlidingWindowAgent`1">
<summary>
 Agent that implements the &quot;sliding window&quot; functionality. It collects
 messages added using the Enqueue method and emits them in overlapping 
 groups of the specified size. For example, given [1,2,3,4,5...] and a 
 size 3, the produced groups will be [1,2,3], [2,3,4], [3,4,5], ...
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncSeq.BufferMessage`1">
<summary>
 A helper type for implementation of buffering when converting 
 observable to an asynchronous sequence
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.AsyncSeq.AsyncSeqBuilder.For``2(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}}})">
<summary>
 Asynchronous for loop - for all elements from the input sequence,
 generate all elements produced by the body (asynchronously). See
 also the AsyncSeq.collect function.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.AsyncSeqBuilder.For``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}}})">
<summary>
 For loop that iterates over a synchronous sequence (and generates
 all elements generated by the asynchronous body)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.AsyncSeq.AsyncSeqBuilder">
<summary>
 Computation builder that allows creating of asynchronous 
 sequences using the &apos;asyncSeq { ... }&apos; syntax
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.skip``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Skips the first N elements of an asynchronous sequence and
 then returns the rest of the sequence unmodified.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.take``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns the first N elements of an asynchronous sequence
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.takeWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated synchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.skipWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.takeWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.zip``2(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Combines two asynchronous sequences into a sequence of pairs. 
 The values from sequences are retrieved in parallel. 
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.cache``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Create a new asynchronous sequence that caches all elements of the 
 sequence specified as the input. When accessing the resulting sequence
 multiple times, the input will still be evaluated only once
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.toBlockingSeq``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to a synchronous blocking sequence.
 The elements of the asynchronous sequence are consumed lazily.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.toObservable``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to an IObservable&lt;_&gt;. When the client subscribes
 to the observable, a new copy of asynchronous sequence is started and is 
 sequentially iterated over (at the maximal possible speed). Disposing of the 
 observer cancels the iteration over asynchronous sequence. 
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofObservable``1(System.IObservable{``0})">
<summary>
 Converts observable to an asynchronous sequence. Values that are produced
 by the observable while the asynchronous sequence is blocked are discarded
 (this function doesn&apos;t guarantee that asynchronou ssequence will return 
 all values produced by the observable)
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofObservableBuffered``1(System.IObservable{``0})">
<summary>
 Converts observable to an asynchronous sequence. Values that are produced
 by the observable while the asynchronous sequence is blocked are stored to 
 an unbounded buffer and are returned as next elements of the async sequence.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofObservableUsingAgent``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpMailboxProcessor{FSharp.Control.AsyncSeq.BufferMessage{FSharp.Control.ObservableUpdate{``0}}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Converts observable to an asynchronous sequence using an agent with
 a body specified as the argument. The returnd async sequence repeatedly 
 sends &apos;Get&apos; message to the agent to get the next element. The observable
 sends &apos;Put&apos; message to the agent (as new inputs are generated).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an asynchronous sequence that lazily takes element from an
 input synchronous sequence and returns them one-by-one.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.filterAsync, but the specified predicate is synchronous
 and processes the input element immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.chooseAsync, but the specified function is synchronous
 and processes the input element immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.iter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.iterAsync, but the specified function is synchronous
 and performs the side-effect immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.mapAsync, but the specified function is synchronous
 and returns the result of projection immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Same as AsyncSeq.scanAsync, but the specified function is synchronous
 and returns the result of aggregation immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Same as AsyncSeq.foldAsync, but the specified function is synchronous
 and returns the result of aggregation immediately.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.foldAsync``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 workflow that returns the final result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.pairwise``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Returns an asynchronous sequence that returns pairs containing an element
 from the input sequence and its predecessor. Empty sequence is returned for
 singleton input sequence.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.iterAsync``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Iterates over the input sequence and calls the specified function for
 every value (to perform some side-effect asynchronously).

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.scanAsync``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 sequence of intermediate aggregation result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.firstOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Asynchronously returns the first element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.lastOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Asynchronously returns the last element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.filterAsync``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are those from the
 input sequence for which the specified function returned true.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.chooseAsync``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Asynchronously iterates over the input sequence and generates &apos;x&apos; for 
 every input element for which the specified asynchronous function 
 returned &apos;Some(x)&apos; 

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.mapAsync``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are generated by 
 applying the specified function to all elements of the input sequence.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``1}}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Creates an asynchronou sequence that iterates over the given input sequence.
 For every input element, it calls the the specified function and iterates
 over all elements generated by that asynchronous sequence.
 This is the &apos;bind&apos; operation of the computation expression (exposed using
 the &apos;for&apos; keyword in asyncSeq computation).
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.tryFinally``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements the &apos;TryFinally&apos; functionality for computation builder
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.tryWith``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}}})">
<summary>
 Implements the &apos;TryWith&apos; functionality for computation builder
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.tryNext``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Tries to get the next element of an asynchronous sequence
 and returns either the value or an exception
</summary>
</member>
<member name="P:FSharp.Control.AsyncSeq.asyncSeq">
<summary>
 Builds an asynchronou sequence using the computation builder syntax
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.append``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Yields all elements of the first asynchronous sequence and then 
 all elements of the second asynchronous sequence.
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.singleton``1(``0)">
<summary>
 Creates an asynchronous sequence that generates a single element and then ends
</summary>
</member>
<member name="M:FSharp.Control.AsyncSeq.empty``1">
<summary>
 Creates an empty asynchronou sequence that immediately ends
</summary>
</member>
<member name="T:FSharp.Control.AsyncSeq">
<summary>
 Module with helper functions for working with asynchronous sequences
</summary>
</member>
<member name="P:FSharp.Control.AsyncSeqExtensions.asyncSeq">
<summary>
 Builds an asynchronou sequence using the computation builder syntax
</summary>
</member>
<member name="T:FSharp.Control.AsyncSeqExtensions">

</member>
<member name="">

</member>
<member name="T:FSharp.Control.BufferAgent">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.Observable.synchronize``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},``0})">
<summary>
 Helper that can be used for writing CPS-style code that resumes
 on the same thread where the operation was started.
</summary>
</member>
<member name="M:FSharp.Control.Observable.delay``1(System.Int32,System.IObservable{``0})">
<summary>
 Delay execution of Observer function
</summary>
</member>
<member name="M:FSharp.Control.Observable.invoke``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Invoke Observer function through specified function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Control.Observable.asUpdates``1(System.IObservable{``0})">
<summary>
 Turns observable into an observable that only calls OnNext method of the
 observer, but gives it a discriminated union that represents different
 kinds of events (error, next, completed)
</summary>
</member>
<member name="M:FSharp.Control.Observable.guard``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Creates an observable that calls the specified function (each time)
 after an observer is attached to the observable. This is useful to 
 make sure that events triggered by the function are handled. 
</summary>
</member>
<member name="M:FSharp.Control.Observable.windowed``1(System.Int32,System.IObservable{``0})">
<summary>
 Returns an observable that yields sliding windows of 
 containing elements drawn from the input observable. 
 Each window is returned as a fresh array.
</summary>
</member>
<member name="T:FSharp.Control.Observable">

</member>
<member name="M:FSharp.Control.Seq.ofAsyncSeq``1(Microsoft.FSharp.Control.FSharpAsync{FSharp.Control.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to a synchronous blocking sequence.
 The elements of the asynchronous sequence are consumed lazily.
</summary>
</member>
<member name="T:FSharp.Control.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.IO.IOExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.BS.GetHashCode">
<summary>
 Gets the hash code for the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.Equals(System.Object)">
<summary>
 Compares two objects for equality. When both are byte strings, structural equality is used.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.BS.Compare(FSharpx.BS,FSharpx.BS)">
<summary>
 Compares two byte strings based on their structure.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.BS">
<summary>
 An ArraySegment with structural comparison and equality.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncEx.Protect``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Encapsulates any possible exceptions during bind in a Choice
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncEx.IgnoreResult``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Ignores (discards) the result of the async computation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``3(System.Func{``0,``1,``2})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``2(System.Func{``0,``1})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``1(System.Func{``0})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``3(System.Action{``0,``1,``2})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``2(System.Action{``0,``1})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``1(System.Action{``0})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction(System.Action)">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="T:FSharpx.FSharpFunc">
 <summary>
 Conversion functions from Action/Func to FSharpFunc
 We need these because FuncConvert often makes C# type inference fail.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Funcs">
<summary>
 Extensions around Actions and Funcs
</summary>
</member>
<member name="M:FSharpx.L.F``3(System.Func{``0,``1,``2})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``2(System.Func{``0,``1})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``1(System.Func{``0})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="T:FSharpx.L">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.ArrayModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterDot``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequentially compose two async actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiply``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_MultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Async.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Async.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Transforms an async value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.pipe``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Flipped map
</summary>
</member>
<member name="M:FSharpx.Async.ap``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterEquals``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Async.returnM``1(``0)">
<summary>
 Inject a value into the async type
</summary>
</member>
<member name="M:FSharpx.Async.bind``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequentially compose two actions, passing any value produced by the second as an argument to the first.
</summary>
</member>
<member name="T:FSharpx.Async">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ByteString.append(FSharpx.BS,FSharpx.BS)">
<summary>
 append uses Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both arrays are copied in,
 disregarding any additional bytes in the original, underlying arrays.
</summary>
</member>
<member name="M:FSharpx.ByteString.cons(System.Byte,FSharpx.BS)">
<summary>
 cons uses Buffer.SetByte and Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both the head and tail are copied in,
 disregarding any additional bytes in the original tail array.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ByteString.|BS|(FSharpx.BS)">
<summary>
 An active pattern for conveniently retrieving the properties of a BS.
</summary>
</member>
<member name="T:FSharpx.ByteString">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.fromOption``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 If Some value, returns Choice1Of2 value. Otherwise, returns the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Choice.toOption``2">
<summary>
 If Choice is 1Of2, returns Some value. Otherwise, returns None.
</summary>
</member>
<member name="M:FSharpx.Choice.mapSecond``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Transforms a Choice&apos;s second value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.choice``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.bimap``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``3},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Choice.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``2,``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Choice.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Choice.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Transforms a Choice&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="M:FSharpx.Choice.protect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0)">
<summary>
 Wraps a function, encapsulates any exception thrown within to a Choice
</summary>
</member>
<member name="M:FSharpx.Choice.get``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="M:FSharpx.Choice.returnM``2(``0)">
<summary>
 Inject a value into the Choice type
</summary>
</member>
<member name="T:FSharpx.Choice">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation.Coroutine">
<summary>
 The coroutine type from http://fssnip.net/7M
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation.Cont`2">
<summary>
 The continuation monad.
 The algorithm is from Wes Dyer http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
 Current implementation from Matt&apos;s gist at https://gist.github.com/628956
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Continuation.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``3,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequentially compose two continuation actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Continuation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Continuation.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``3},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``3},``3}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``3},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``3},``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Continuation.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Transforms a Cont value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Continuation.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Continuation.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Continuation.returnM``2(``0)">
<summary>
 Inject a value into the Cont type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Core.AssemblyInfo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.DList`1">
<summary>
 The DList is an implementation of John Hughes&apos; append list.
 See http://dl.acm.org/citation.cfm?id=8475 for more information.
 This implementation adds an additional parameter to allow a more
 efficient calculation of the list length.
 Note that an alternate form would represent the DList as:
 type DList&lt;&apos;a&gt; = DList of (&apos;a list -&gt; &apos;a list)
 An example can be found at http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5327209#5327209
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BootstrappedQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.BottomUpMergeSort">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.DList.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,FSharpx.DataStructures.DList{``1})">
<summary>
 Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.DList">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.Exceptions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.ImplicitQueue">

</member>
<member name="P:FSharpx.DataStructures.Interfaces.IVector`1.Item(System.Int32)">
<summary>
 Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Pop">
<summary>
 Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Peek">
<summary>
 Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Count">
<summary>
 Returns the number of items in the collection.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.Conj(`0)">
<summary>
 Returns a new vector with the element &apos;added&apos; at the end.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Interfaces.IVector`1.AssocN(System.Int32,`0)">
<summary>
 Returns a new vector that contains the given value at the index. Note - index must be &lt;= vector.Count.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.Interfaces">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.RealTimeQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Vector.assocN``1(System.Int32,``0,FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns a new vector that contains the given value at the index. Note - index must be &lt;= vector.Count.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.pop``1(FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.peek``1(FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.cons``1(``0,FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns a new vector with the element &apos;added&apos; at the end.   
</summary>
</member>
<member name="M:FSharpx.DataStructures.Vector.nth``1(System.Int32,FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.DataStructures.Vector.count``1(FSharpx.DataStructures.Interfaces.IVector{``0})">
<summary>
 Returns the number of items in the collection.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DataStructures.Vector">
<summary>
 vector implementation ported from https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentVector.java
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.DictionaryModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Distribution.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``0}})">
<summary>
 Transforms a Distribution value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Distribution.returnM``1(``0)">
<summary>
 Inject a value into the Distribution type
</summary>
</member>
<member name="M:FSharpx.Distribution.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``1}}},System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``0}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Distribution.op_GreaterGreaterEquals``2(System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``0}},Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Distribution">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scanUntil``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state until the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Enumerator.scanWhile``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state while the provided predicate is true.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Enumerator">

</member>
<member name="M:FSharpx.IO.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="P:FSharpx.IO.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:FSharpx.IO.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:FSharpx.IO.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:FSharpx.IO.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:FSharpx.IO.convertTextToWindowsLineBreaks(System.String)">
<summary>
 Converts the given text from linux or mac linebreaks to windows line breaks
</summary>
</member>
<member name="M:FSharpx.IO.replaceFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:FSharpx.IO.writeStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes a single string to a file
</summary>
</member>
<member name="M:FSharpx.IO.writeToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:FSharpx.IO.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:FSharpx.IO.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:FSharpx.IO.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:FSharpx.IO.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:FSharpx.IO.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:FSharpx.IO.getFullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:FSharpx.IO.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IO">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Enumeratee`3">
<summary>
 An enumeratee is an enumerator that produces an iteratee using another iteratee as input.
 Enumeratees can be used for tasks such as encoding or encrypting data.
</summary>
</member>
<member name="T:FSharpx.Iteratee.Enumerator`2">
<summary>
 An enumerator generates a stream of data and feeds an iteratee, returning a new iteratee.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Iteratee`2">
<summary>
 The iteratee is a stream consumer that will consume a stream of data until either 
 it receives an EOF or meets its own requirements for consuming data. The iteratee
 will return Continue whenever it is ready to receive the next chunk. An iteratee
 is fed data by an Enumerator, which generates a Stream. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Stream`1">
<summary>
 A stream of chunks of data generated by an Enumerator.
 The stream can be composed of chunks of &apos;a, empty blocks indicating a wait, or an EOF marker.
 Be aware that when using #seq&lt;_&gt; types, you will need to check for both Seq.empty ([]) and Empty.
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,FSharpx.Iteratee.Iteratee{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,FSharpx.Iteratee.Iteratee{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,FSharpx.Iteratee.Iteratee{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_GreaterGreaterDot``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,``2})">
<summary>
 Sequentially compose two iteratee actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_LessMultiply``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_MultiplyGreater``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Iteratee.ap``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_LessMultiplyGreater``3(FSharpx.Iteratee.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},FSharpx.Iteratee.Iteratee{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Binary">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Primitives">

</member>
<member name="T:FSharpx.Iteratee">

</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.listToArray``2(FSharpx.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Converts a lens that views a list into a lens that views an array
</summary>
</member>
<member name="M:FSharpx.LensModule.xmap``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``0},FSharpx.Lens{``2,``0})">
<summary>
 Applies an isomorphism to the value viewed through a lens
</summary>
</member>
<member name="M:FSharpx.LensModule.seqMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a sequence
</summary>
</member>
<member name="M:FSharpx.LensModule.arrayMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.listMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forList``1(System.Int32)">
<summary>
 Lens for a particular position in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forArray``1(System.Int32)">
<summary>
 Lens for a particular position in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.forMap``2(``0)">
<summary>
 Lens for a particular key in a map
</summary>
</member>
<member name="M:FSharpx.LensModule.forSet``1(``0)">
<summary>
 Lens for a particular value in a set
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.id``1">
<summary>
 Identity lens
</summary>
</member>
<member name="M:FSharpx.LensModule.snd``2">
<summary>
 Gets/sets the snd element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.fst``2">
<summary>
 Gets/sets the fst element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.modifyAndGetState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the modified value.
</summary>
</member>
<member name="M:FSharpx.LensModule.getAndModifyState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the original value.
</summary>
</member>
<member name="M:FSharpx.LensModule.updateState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1},``0)">
<summary>
 Update through a lens within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.setState``2(FSharpx.Lens{``0,``1},``1,``0)">
<summary>
 Applies a lens in the &apos;set&apos; direction within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.getState``2(FSharpx.Lens{``0,``1},``0)">
<summary>
 Applies a lens in the &apos;get&apos; direction within a state monad      
</summary>
</member>
<member name="M:FSharpx.LensModule.cond``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},FSharpx.Lens{``0,``1},FSharpx.Lens{``0,``1})">
 <summary>
 <paramref name="pred"/> is applied to source. 
 If true, <paramref name="lensTrue"/> is selected.
 If false, <paramref name="lensFalse"/> is selected.
 </summary>
</member>
<member name="M:FSharpx.LensModule.pair``4(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``3})">
<summary>
 Pair two lenses
</summary>
</member>
<member name="M:FSharpx.LensModule.choice``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``1})">
<summary>
 Composes two lenses through a sum in the source
</summary>
</member>
<member name="M:FSharpx.LensModule.compose``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``0})">
<summary>
 Sequentially composes two lenses
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.StateOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.Operators">

</member>
<member name="T:FSharpx.LensModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Curried cons
</summary>
</member>
<member name="T:FSharpx.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.OptionMonoid`1">
<summary>
 Option wrapper monoid
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.ListMonoid`1">
<summary>
 List monoid
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid.Monoid`1.mconcat(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Fold a list using this monoid
 </summary>
</member>
<member name="M:FSharpx.Monoid.Monoid`1.mappend(`0,`0)">
 <summary>
 Associative operation
 </summary>
</member>
<member name="P:FSharpx.Monoid.Monoid`1.mempty">
 <summary>
 Identity
 </summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.Monoid`1">
<summary>
 Monoid (associative binary operation with identity)
 The monoid implementation comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="P:FSharpx.Monoid.IntProductMonoid">
<summary>
 Monoid (int,1,*)
</summary>
</member>
<member name="P:FSharpx.Monoid.IntSumMonoid">
<summary>
 Monoid (int,0,+)
</summary>
</member>
<member name="T:FSharpx.Monoid">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.NameValueCollectionModule.fromSeq(System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}})">
 <summary>
 Creates a <see cref="NameValueCollection"/> from a list of key-value pairs
 </summary>
 <param name="l"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.toList(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a list of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.ToEnumerable(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a sequence of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.ToArray(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as an array of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.add(System.String,System.String,System.Collections.Specialized.NameValueCollection)">
<summary>
 Adds an element to a copy of an existing NameValueCollection
</summary>
</member>
<member name="M:FSharpx.NameValueCollectionModule.addInPlace(System.Collections.Specialized.NameValueCollection,System.String,System.String)">
 <summary>
 In-place add of a key-value pair to a <see cref="NameValueCollection"/>
 </summary>
 <param name="x"></param>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.Concat(System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a new <see cref="NameValueCollection"/> with the concatenation of two <see cref="NameValueCollection"/>s
 </summary>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="T:FSharpx.NameValueCollectionModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Nullable.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Nullable.toList``1(System.Nullable{``0})">
<summary>
 Convert the nullable to a list of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.toArray``1(System.Nullable{``0})">
<summary>
 Convert the nullable to an array of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Nullable{``0})">
<summary>
 Transforms a Nullable value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Nullable.iter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Nullable{``0})">
<summary>
 Executes a function for a nullable value.
</summary>
</member>
<member name="M:FSharpx.Nullable.forall``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.forall for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.exists``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.exists for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.foldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Nullable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},System.Nullable{``0},``1)">
<summary>
 Performs the equivalent of the List.foldBack operation on a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Nullable{``1})">
<summary>
 Evaluates the equivalent of List.fold for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.count``1(System.Nullable{``0})">
<summary>
 Returns 1 if Nullable has value, otherwise 0
</summary>
</member>
<member name="M:FSharpx.Nullable.isNull``1(System.Nullable{``0})">
<summary>
 True if Nullable does not have value
</summary>
</member>
<member name="M:FSharpx.Nullable.hasValue``1(System.Nullable{``0})">
<summary>
 True if Nullable has value
</summary>
</member>
<member name="M:FSharpx.Nullable.bind``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Nullable{``1}},System.Nullable{``0})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Nullable.toOption``1">
<summary>
 Converts nullable to option
</summary>
</member>
<member name="M:FSharpx.Nullable.fromOption``1">
<summary>
 Converts option to nullable
</summary>
</member>
<member name="M:FSharpx.Nullable.get``1(System.Nullable{``0})">
<summary>
 Gets the value associated with the Nullable.
 If no value, throws.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrElse``1(System.Nullable{``0},System.Lazy{``0})">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrDefault``1(System.Nullable{``0},``0)">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Nullable">

</member>
<member name="M:FSharpx.Operators.applyM``7(``0,``5,``1,``6)">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Operators.returnM``3(``0,``1)">
<summary>
 Inject a value into the monadic type
</summary>
</member>
<member name="T:FSharpx.Operators">
<summary>
 Generic monadic operators    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Option.MaybeBuilder">
<summary>
 The maybe monad.
 This monad is my own and uses an &apos;a option. Others generally make their own Maybe&lt;&apos;a&gt; type from Option&lt;&apos;a&gt;.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Option.Cast``1(System.Object)">
<summary>
 Attempts to cast an object. Returns None if unsuccessful.
</summary>
</member>
<member name="M:FSharpx.Option.filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.orElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrDefault``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the default value for the type.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseF``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value from a function.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseLazy``1(System.Lazy{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElse``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.fromChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Maps Choice 1Of2 to Some value, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.fromBoolAndValue``1(System.Boolean,``0)">
<summary>
 If true,value then returns Some value. Otherwise returns None.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.tryParseWith``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Tuple`2{System.Boolean,``1}})">
<summary>
 Converts a function returning bool,value to a function returning value option.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.fromBool(System.Boolean)">
<summary>
 True -&gt; Some(), False -&gt; None
</summary>
</member>
<member name="M:FSharpx.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Maps an Option to Nullable
</summary>
</member>
<member name="M:FSharpx.Option.fromNullable``1(System.Nullable{``0})">
<summary>
 Maps a Nullable to Option
</summary>
</member>
<member name="M:FSharpx.Option.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequentially compose two maybe actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Option.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Option.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Option.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Option.ap``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Option.returnM``1(``0)">
<summary>
 Inject a value into the option type
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Prelude.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Creates a 6-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Creates a 5-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple4``4(``0,``1,``2,``3)">
<summary>
 Creates a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple3``3(``0,``1,``2)">
<summary>
 Creates a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple2``2(``0,``1)">
<summary>
 Creates a pair
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader.ReaderBuilder">
<summary>
 The reader monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/07/much-ado-about-monads-reader-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Reader.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequentially compose two reader actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Reader.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Reader.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``3,``0},Microsoft.FSharp.Core.FSharpFunc`2{``3,``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Reader.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0})">
<summary>
 Transforms a Reader value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Reader.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``2}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Reader.returnM``2(``0)">
<summary>
 Inject a value into the Reader type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.RegexModule.tryMatchWithOptions(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
flags:RegexOptions -&gt; pattern:string -&gt; input:string -&gt; Regex.ActiveMatch option
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Interpreted">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Compiled">

</member>
<member name="T:FSharpx.RegexModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Seq.tryFindWithIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Returns the first element (with its index) for which the given function returns true.
 Return None if no such element exists.
 </summary>
 <param name="pred">Predicate</param>
 <param name="l">Sequence</param>
</member>
<member name="M:FSharpx.Seq.index``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Adds an index to a sequence
 </summary>
 <param name="a"></param>
</member>
<member name="T:FSharpx.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State.StateBuilder">
<summary>
 The state monad.
 The algorithm is adjusted from my original work off of Brian Beckman&apos;s http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
 The approach was adjusted from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.State.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``3,``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.State.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.State.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``3,System.Tuple`2{``0,``3}},Microsoft.FSharp.Core.FSharpFunc`2{``3,System.Tuple`2{``1,``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.State.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.State.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Transforms a State value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.State.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.State.returnM``2(``0)">
<summary>
 Inject a value into the State type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ListQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ArrayQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core">

</member>
<member name="T:FSharpx.Stm">
 <summary>The Software Transactional Memory monad.</summary>
 <see href="http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx" />
</member>
<member name="M:FSharpx.Strings.niceName(System.String)">
<summary>
 Turns a string into a nice PascalCase identifier
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Strings.singularize(System.String)">
<summary>
 Returns the singularized version of a noun
</summary>
</member>
<member name="M:FSharpx.Strings.pluralize(System.String)">
<summary>
 Returns the pluralized version of a noun
</summary>
</member>
<member name="M:FSharpx.Strings.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="M:FSharpx.Strings.separatedBy(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a single string separated with the delimiters
</summary>
</member>
<member name="M:FSharpx.Strings.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:FSharpx.Strings.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether the specified substring occurs within this string
</summary>
</member>
<member name="M:FSharpx.Strings.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given &quot;replacement&quot; for every occurence of the pattern in the given text 
</summary>
</member>
<member name="M:FSharpx.Strings.startsWith(System.String,System.String)">
<summary>
 Checks whether the given text starts with the given prefix
</summary>
</member>
<member name="T:FSharpx.Strings">

</member>
<member name="M:FSharpx.TimeMeasurement.compareTwoRuntimes``2(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},System.String,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Stops the average runtime for the given functions
 Afterwards it reports it with the given descriptions
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAndReportAvarageTime``1(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
 Afterwards it reports it with the given description
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAverageTime``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopTime``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the runtime for a given function
</summary>
</member>
<member name="T:FSharpx.TimeMeasurement">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Undo">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.CustomValidation`1.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apr``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apl``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.ap``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``3}},Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``2}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.apm``3(FSharpx.Monoid.Monoid{``0})">
<summary>
 Sequential application, parameterized by monoid
</summary>
</member>
<member name="M:FSharpx.Validation.apa``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Core.FSharpChoice{``1,``0},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},``0})">
<summary>
 Sequential application, parameterized by append
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Validation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Writer.WriterBuilder`1">
<summary>
 The writer monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``2,Microsoft.FSharp.Collections.FSharpList{System.String}}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Writer.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Writer.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Writer.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Transforms a Writer value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Writer.ap``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.returnM``2(FSharpx.Monoid.Monoid{``0},``1,Microsoft.FSharp.Core.Unit)">
<summary>
 Inject a value into the Writer type
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Writer">

</member>
<member name="M:FSharpx.ZipList.op_LessMultiply``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.op_MultiplyGreater``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ZipList.ap``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiplyGreater``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.ZipList">

</member>
</members>
</doc>
